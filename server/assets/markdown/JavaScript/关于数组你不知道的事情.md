# 关于Array你不知道的事情

资料来源：

- [从V8引擎来看JS中这个“假数组”](https://juejin.cn/post/6847902222009925640)
- [JS V8|深入理解JS数组---JS Array在内存上分配的空间是连续的吗？](https://zhuanlan.zhihu.com/p/371236424)

在 `javascript` 中。`Array` 在内存上分配的空间是连续的吗？

比如 `[1,2,3]` 就是连续的吗？

`Array` 又分为什么数组。是 `快数组(fast Array)` 还是 `慢数组(slow Array)` 呢？

维基百科解释：数组是由**相同类型**的元素（element）的集合所组成的数据结构，分配一块**连续内存**来存储。

根据维基百科解释得到结论：

1. 不同数据类型存储所需空间大小不同。
2. JS中用来存放数组的内存地址一定不是连续的（除非类型相同）。

## V8引擎下数组的实现

JS代码是如何在计算机上被执行的。和Python一样，它作为一门解释性语言，需要宿主环境去对它进行“转换”，然后再由机器运行机器码，也就是二进制。我们平时对JS的讨论很多都是（默认）基于浏览器来讲的，当前大多主流**浏览器**底层都是基于C++来开发的，并且Node底层也是基于Chrome V8引擎的JS运行环境，而V8底层也是基于C++来开发的。所以会有开发者认为**JavaScript是用C++写的**，这是不对的。

作为一门解释型语言，JS并非只有C++才能去解析JS，其实还有：

- D：DMDScript
- Java：Rhion、Nashorn、DynJS、Truffle/JS 等。
- C#：Managed JScript、SPUR 等等。

## JS数组就是“对象”？

还记得当初怎么说的吗？**万物皆对象**，如果说JS中的数组底层是一个对象，那么就可以解释为什么JS中数组可以放各种类型了。

使用 `v8-debug` 引擎去 debug 打印他转译的字节码，得到结论，其实 `Array` 就是一个 `map`，它有key，有value，而key就是数组的索引，value就是数组中的元素。

## 数组的特殊性

在 `javascript` 中。`Array` 的长度是可以任意修改的。例如：

```js
const arr = [1, 'abc', [2]]; // * 同一个数组下的不同类型的元素。
console.log(arr.length); // * 打印 3

arr[arr.length] = 'hello';
console.log(arr.length); // * 打印 4
```

1. 同一个JS数组的元素可以是**不同的数据类型**，那么肯定没法固定长度维每个元素分配空间，那么这样的数组也就没办法通过元素的索引来计算出某个元素对应的存储地址。
2. JS数组可以**任意更改大小**，看到这里，JS数组在内存中分配的空间还是连续的吗？如果是连续的，如果无限制增加数组的大小，怎么保证后面的区域也是可以分配给数组的呢？

## 初探JS数组

在JS中数组存在两种形式，一种是与 `C/C++` 等相同的在连续内存中存放数据的**快数组**，另一种是 `HashTable` 结构的**慢数组**，是一种典型的**字典形式(字典相当于JS中的Map)**。在V8引擎中，直接创建数组默认的方式是创建**快数组**，会直接为数组开辟**一定大小连续的内存**。

例子：

第一步：打开浏览器 `Developer Tools` 的 `Memory` 选项卡，选择 `Allocation instrumentation on timeline` 然后可以产看当时我们用了多大内存。

然后在浏览器的 `Console` 中执行以下代码：

```js
const LIMIT = 6 * 1024 * 1024;
let arr = new Array(LIMIT);
```

观察 `Memory` 是否是增加了(不出意外会的)，大概增加了 `25MB` 左右。说明开辟了一块内存区域供数组使用，那我们如何知道这一块内存区域是否是连续的呢？

回想数据结构中的知识：如果系统为该数组分配的是一块连续的内存，那么在这个数组上的遍历速度应该是很快的，那么我们可以计算一下遍历数组大概需要多少时间：

```js
console.time("Array");
for(let i = 0; i < LIMIT; i++) arr[i] = i;
console.timeEnd("Array");
```

大概打印了 `10ms` 左右，现在我们知道了快数组是和 `c/c++` 等语言类似的为其分配连续固定大小的内存空间，那如果我们此时改变数组的大小，会发生什么事？

```js
arr[arr.length+1026] = 1
console.time("Array+1026");

for(let i = 0; i < LIMIT; i++) arr[i] = i; 
console.timeEnd("Array+1026");
```

当我们为数组新增1027 （arr[arr.length+1026] = 1意味着最大索引是arr.length+1026，所以我们为数组增加了1027个长度）个长度后，再次遍历数组，所需要开销的时间多了100倍左右，我们只是增加了1027个元素为什么遍历效率会低这么多？对！它“变了”！它再也不是原来那个快数组了，它变“慢”了，变成了慢数组。看到这里大家肯定觉得有点懵，怎么就变了？什么情况下会变？你倒是说清楚啊！别急，下面我们就来研究研究它为什么“变了”？

## 快数组与慢数组

类比快满属性，再看我们上一节中举的例子：

```js
const LIMIT = 6 * 1024 * 1024;
let arr = new Array(LIMIT); // 快数组
arr[arr.length + 1026] = 1; // 慢数组
```

这个例子中，在行 `2` 声明完毕后 `arr` 是一个空数组，但是在第 `3` 行马上又定义索引 `arr.length + 1025` 处值为 `1` ，此时如果为 `arr` 创建一个长度为 `arr.length + 1026 + 1` 的数组连续内存来存储这样的**稀疏数据**将会非常占用内存，为了应对这种情况，V8会将数组降级为**慢数组**，创建一个**字典**来存储「`键、值、描述符`」（key、value、description）三元组。当使用 `Object.defineProperty` 自定义 `key、value、description` 时，V8 都会使用**慢属性**，对应到数组中就是**慢数组**。

在 V8 源码注释中有这样一段描述：

```text
Such an array can be in one of two modes:
- fast, backing storage is a FixedArray and length <= elements.length();
- slow, backing storage is a HashTable with number as keys.
```

翻译一下，一个数组含有两种模式：

- 快（模式）：后备存储是一个FixedArray，长度 <= elements.length
- 慢（模式）：后备存储是一个以数字为键的HashTable。

那么来思考下为什么要V8要将数组这样“设计”，动机是什么？无非就是为了提升**性能**，一说到性能，就不得不提内存，总之这一切无非就是：

> 牺牲**性能**节省**内存**，牺牲**内存**提高**性能**

这是时间换空间，空间换时间的博弈，最后看到底哪个“划算”（合理）。

### 快数组

快数组是一种线性存储，其长度是可变的，可以动态调整存储空间。其内部有扩容和收缩机制。扩容时计算新容量是根据基于旧的容量来的：

> 新容量 = 旧容量 + 50% + 16

因为JS数组是动态可变的，所以这样安排的**固定空间**势必会造成内存空间的损耗。然后扩容后会将数组拷贝到新的内存空间。

它的判断依据是：当前容量是否大于等于当前数组长度的2倍+16，此外的都填入 `Holes` (空洞)对象。什么是Holes，简单理解就是数组分配了空间但没有存入元素，这里不展开。快数组就是空间换时间来提升JS数组在性能上的缺陷，也可以说这是参照编译型语言的设计的一种“数组”。

一句话总结：**V8用快数组来实现对内存空间的连续（增加内存提升性能），但由于JS是弱类型语言，空间无法固定，所以使用数组的length来作为依据，在底层进行内存的重新分配。

### 慢数组

慢数组底层实现使用的是 `HashTable` 哈希表，相比于快数组，他不用开辟大块的连续空间，从而节省内存，但无疑执行效率是比快数组要低的（时间换空间）。